In this chapter, we will take a closer look at the macroscopic level – simply referred to as _the service_ itself. This layer is what our end-user is actually interacting with; the face of the complicated inner workings that all together perform to generate the service's outcome.

### Drawing the line

Our model defines both this macroscopic level as well as the microscopic level as `services`, as it applies to both. In Chapter 2, we have applied our model to `grep` and `ls`, and then encapsulated them with a third service that uses `ls` and `grep` internally: `sd`. This is what we can refer to as the _Service Baseline_. 

When we apply this model, we can do so at different levels in our system in order to analyze different parts. Let us say we are designing a simple service that learns from your music listening history and recommends you a new track you will most probably like every day. Our users are interacting with the service as a whole, and do not care or know about its inner workings. Thus, our _Service Baseline_, the macroscopic layer, is the "app", or whatever medium our end-users who we are providing value for, interacts through to use our service. This medium, in a more detailled model, acts as a user to a multitude of services behind scenes – our micro-layer.

## Humans as users

While in Chapter 2's micro-layer, the users of our services are machines, at the macro-level, our users are humans. Since our end-goal is solving needs for these very human users, this layer defines our design approach and ultimately dictates our service's design as a whole. This is where _User experience_ (UX) and _User interface_ (UI) design come into play.

The international standard ISO 9241-210 defines _User Experience_[@userExperienceDefinition]:

> User Experience is a person's perceptions and responses that result from the use or anticipated use of a product, system or service.

Most services, unless their existance is justified by necessity or scarcity alone, need to optimize User Experience in order to convert and retain their customers. And because our end-users are human, human-centered design is one of the most important paradigms in shaping and designing a service.

User Experience and User Interface are often used interchangably – but in reality, their meaning is different in very important ways. 

The Oxford Dictionary defines _User Interface_[@userInterfaceDefinition]:

> The means by which the user and a computer system interact, in particular the use of input devices and software.

The User Interface can thus be summarized as the _medium_ our user interacts with our service through. 

<img src="/thesis/img/UI.svg">

Many aspects of this are standardized; in the example of a web application or website for instance, a user is as of writing 63.4% likely to access a website through a mobile device, such as a smartphone[@smartphoneUsage]. As such, naturally the scope of user interface design for such a product is restricted to the website itself – typically living inside a web browser. _User Experience Design_, however, goes beyond this – in fact, the conclusion of choosing the web as a medium is, due to the vast implications on perception, a key User Experience decision. 

To sum it up; _User Experience Design_ is optimizing the qualitative sum of experiences and perceptions in the context of interacting with a product. The _User Interface_ is the medium that a user interacts with while using a service.

### Lowering cognitive complexity

In Chapter 2, we have briefly looked at the world of engineering and one of its most important paradigms — "don't repeat yourself": Defining constants and functionality as re-usable atomic bits that are shared across all dependent mechanisms.

Product Designer Brandon Oxendine highlights a very similar line of thinking in designing the actual interfaces that users interact with.

> [...] if you’re starting with a system — a system of components, a structure of where things in the app live — then it should be relatively clear where to place things. It’s important to understand the basic functions of your app, like let’s say adding an item in a to-do app, and putting those basic functions into logical groups where they can be reused elsewhere in the experience. So you don’t end up designing two ways of adding a to-do in two different locations.[@brandonInterview]

When asked about why having two different ways to achieve the same thing, he continued:

> If you reduce the total amount of concepts a user has to learn in order to use the app, then the app becomes easier to understand. [...] More screens, really, more anything in your app automatically makes it harder to understand, naturally. Your users won’t understand why there’s two ways to do the same thing, they'll think that there has to be a difference somehow. [@brandonInterview]

In Chapter 1, we have learned from Engineers that achieving the same end-result in different ways in the context of a single service introduces problems — in User Experience Design, it is also considered bad practice, but resulting from a very different perspective: The unnecessary complexity directly affects your users, who after all are the ones that actually need to understand a user interface in order to use a service.

### Matching concepts across use-cases

B. Oxendine brings up the example of a to-do service, in which you can create to-dos and then set reminders for those to-dos. 

> (...) think of the things you can do with a to-do in this theoretical to-do app: you can create one, edit it, delete it, maybe put a reminder on it. [...] It wouldn’t be good to create to-dos and reminders as separate concepts. They should exist in the same system. [@brandonInterview]

What becomes apparent now: A service that solves multiple interconnected use-cases should tie their resolutions together so that the service as a whole is aligned and easy to understand. But what is it about reminders and to-dos specifically that makes it natural to merge them into one "concept"?

> Well, a to-do has everything a reminder needs to be useful, like, some text, a deadline and a checkbox, and a reminder is like an extension of that. In this case maybe you get a notification about your to-do. You can create reminder functionality by notifying a user about a to-do and the other way around it doesn’t really work.[@brandonInterview]

When asked about why exactly "it doesn't really work" the other way around, Oxendine clarifies that he is talking from experience and intuition ("I mean this is all hypothetical — actually, you’d want to test this kind of stuff with real users"[@brandonInterview]), but raises an interesting point: 

> the to-do should be the basis of this kind of app, because you can extend a to-do with a reminder. You could also create reminders and then remove the notification to get a simple to do. But see, now, the concept is getting harder to understand. Generally, the whole point I’m trying to make is — one way or the other, these two ideas are so similar, they should be the same concept (...).[@brandonInterview]

Oxendine's line of thinking in general can be summed up to making a service as simple as possible — and that entails breaking down use-cases (like creating a to-do and creating a reminder) into small parts, which can then be assembled into patterns that reduce the amount of _concepts_ required to be understood in order to use a digital product. 

## Need diversity

Now, let us apply this knowledge to our service model by breaking down needs and outcomes into atomic bits.

In Chapter 1, we have defined _Needs_ and a service's _outcome_ as main aspects of defining a service; the user approaches with their needs, and our service, through its performance, provides an outcome that aims to resolve those needs. 

Of course, as diverse as humans are, so are the exact set of needs of users. Depending on context and the specialization of a service, there might be a narrow or extremely wide range of specific use-cases – manifesting in patterns in respective sets of needs.

By comparing the set of needs with the ultimately provided outcome, we can measure _how well_ our service _fits_ the need pattern associated with a specific usecase. This approach exhibits parrallels to the concept of _Product/Market Fit_ (PMF), an important dimension in Product Development and User Research. American Entrepeneur Marc Andreesen defined PMF as "being in a good market with a product that can satisfy that market."[@pmf].

### Case resolution

In our model, we can thus define a _resolution_ for each _use-case_ (use-case = recurring pattern in set of needs). Let us refer to this as the _case resolution_. When looking at the relevant parts from our diagram in Chapter 1, we can represent the case resolution as an overlap between the user's set of needs and our service's end result.

<img src="/thesis/img/caseResolution.svg">

In this representation, everything a service provides that is not part of the set of needs is represented as _overhead_. In parallel, everything in the set of needs that is _not_ part of the outcome is _loss_. When optimizing for a certain usecase, _case resolution_ should grow, in turn minimizing _loss_. By reducing _overhead_, ultimately unnecessary functionality can be cut, improving agility and reducing cost of the product development and maintenance process. Of course, the overhead in a specific use-case might be a vital contribution towards the case resolution of other use-cases[@overheadLoss]. 

### Service resolution

By summing up all sets of needs we can define a macro-level dimension of our service model: the _service resolution_. The service resolution simply describes an overall Product/Market fit by representing how well our service solves real user needs across all use-cases. 

In order to calculate service resolution across use-cases, let us calculate the average of case resolutions.

<img src="/thesis/img/serviceResolution.svg">

## Quantifying Needs and Outcomes

So far, we have looked at the Service Resolution only as the intersection of the Set of Needs and Outcome, with both being of arbitrary _breadth_. In reality of course, some Sets of Needs are _more diverse_ in themselves — meaning, their resolution requires more or less losely defined effort. For example, two use-cases of a banking app might include "Viewing account balance" and "Making a transfer". The latter need is more complicated to solve as a direct result of the sum of _resolution complexities_ for all resolutions involved. Of course, a singular use-case may include many seperate features, and multiple use-cases may share the same performance. For example, viewing the updated account balance after submitting a transfer may be considered part of the "Making a transfer" use-case.

By defining _resolutions_ as small building-blocks that meet their directly equivalent _need_, we are able to quantify _breadth_:

<img src="/thesis/img/Breadth.svg">

This way, we can assess _case resolution_ on a need-by-need basis, allowing us to exactly pinpoint which resolutions are actually required to meet our main use-cases.

### Service breadth

Analog to _case resolution_ and _service resolution_, we can upscale _breadth_ of case-specific needs and outcomes — _service breadth_. Instead of taking the average _breadth_ across all use-cases, as we are now counting an absolute number of _needs_ and _resolutions_, we can simply add together the number of unique needs. This means that, going back to the banking app example, the need "View account balance", which may be part of use-cases "Making a transfer" and, naturally, "Viewing account balance", is only counted once despite being part of two seperate sets of needs. 

By combining _service resolution_ and _service breadth_, we can now review exactly which of our resolutions solve real needs, how many needs are left unsolved, and which resolutions are not actually _needed_.